;                                                                 -*- asm -*-
; Hello World for the bbmachine
; Using vasm:
; vasm6502 -wdc02 -Fbin -dotdir -L helloworld.lst \
;     -o helloworld.bin helloworld.vasm

;.include "bbmac.inc"
;---------------- Program Info ----------------

DATA = $0200
ENTRY = $0400

;------------ Console Device -----------
; Control and data registers.
; Write data register first, then control register to process.
;
CONS_CTRL = $BF00
CONS_DATA1 = $BF01

; Console commands
CONS_CMD_PRINT = $00
CONS_CMD_FLUSH = $01
CONS_CMD_CLEAR = $02
;--------------------------------


;;; ----------------
;	.ZEROPAGE
	.org 0
ptr1:	.word $0000
cons:	.word CONS_CTRL

;;; ----------------
	.org $0200
hello:	.asciiz "Hello, World!"
goodbye: .asciiz "Goodbye, World!"

  .macro PUTS, str ; param1=string location
	lda #<\str
	sta ptr1
	lda #>\str
	sta ptr1+1
	jsr print
  .endmacro
	
;;; ----------------
;	.assert * < $0400, error, "Data is too long, extends into $0400"
;	.code
	.org $0400
start:
	PUTS hello
	PUTS goodbye
	stp

;; ----------------------------------------------------------------
;	.segment "ROM"
	.org $C000

;;; PRINT subroutine
;;; Param: ptr1(zp) contains address of null-terminated string.
;;; Uses indirect indexed off Y via ptr1
print:
	ldy #0				    ; char index
next:	lda (ptr1),y
	beq flush			    ; if Z, end of string.
	phy				    ; save Y
	
	ldy #1				    ; write char to data reg (cons)+1
	sta (cons),y
	
	lda #CONS_CMD_PRINT		    ; write print cmd to ctrl reg (cons)+0
	ldy #0
	sta (cons),y
	
	ply				    ; restore index value
	iny				    ; incr index
	jmp next			    ; loop
	
flush:	jsr ConsFlush
	rts

;;; ConsClear sends the clear command to the console.
;;; Uses cons(zp) to store I/O address, A, Y.
ConsClear:
	lda #CONS_CMD_CLEAR		    ; write clear command
	ldy #0
	sta (cons),y			    ; (cons)+0
	rts

;;; ConsFlush sends the flush command to the console.
;;; Uses cons(zp) to store I/O address, A, Y.
ConsFlush:
	lda #CONS_CMD_FLUSH		    ; write clear command
	ldy #0
	sta (cons),y			    ; (cons)+0
	rts

;;;
;;; NMI trap
nmi_vec:
	stp

;;;
;;; Reset
res_vec:
	jmp start

;;;
;;; IRQ trap
irq_vec:
	stp

;	.segment "VECTORS"
	.org  $FFFA
        .word nmi_vec
        .word res_vec
        .word irq_vec
